# 改訂版：追加30日（Day 31–60）：Goで「現場で戦えるAPI」へ育てる（フレームワーク理解込み）

前提：Day1–30で作ったTODO API（Go）をベースに、**1日1〜2時間**で「運用・保守に耐える」形へ近づけます。  
この改訂版では特に、**フレームワーク（FW）を“選定→導入→載せ替え→作法まで体得”**する学習を強化しています。  
※毎日、手を動かした結果として **必ず成果物が1つ以上残る**ようにしています。

---

## Week 6：フレームワーク導入で“現場の型”に寄せる
**目標:** net/http直書きから、**Goの定番Webフレームワーク**で「現場の作法」を体得する。  
（例：Gin / Echo / chi のどれか *1つ* を主軸にする。比較は軽く、実装は1つに集中。）

### Day 31: フレームワーク地図を作って選定する
- 学習項目: Gin/Echo/chi（など）の思想と違い、採用理由の言語化、ロックインの捉え方
- 成果物: 「今回採用するFW」と「選定理由」メモ（README追記）

### Day 32: FWで最小サーバを立てる（Hello + health）
- 学習項目: ルータ、ハンドラ署名、起動方法、`net/http`との対応関係
- 成果物: `/health` をFWで実装して起動できる

### Day 33: ルーティング載せ替え（GET/POSTから）
- 学習項目: ルーティング、パスパラメータ、クエリ、グルーピング
- 成果物: TODOの `GET /todos` `POST /todos` をFWへ移植

### Day 34: Middlewareの作法（ログ・recovery・request_id）
- 学習項目: ミドルウェアチェーン、順序、contextの持ち方
- 成果物: logging + recovery + request_id をFWミドルウェアで統一

### Day 35: リクエストバインドとバリデーション
- 学習項目: JSON bind、validation（FW標準 or 外部）、エラーレスポンスとの結合
- 成果物: `POST /todos` を「入力→検証→失敗応答」が一貫する形にする

### Day 36: エラー設計をFW前提で統一する
- 学習項目: handler内のエラー→HTTP変換、アプリ共通エラー型、レスポンス形式の固定
- 成果物: エラー仕様（JSON）と実装（エラーハンドラ/ミドルウェア）

### Day 37: 設定管理 + graceful shutdown（FW込み）
- 学習項目: 設定の優先順位（env/flag/default）、`Shutdown`、タイムアウト
- 成果物: config導入 + Ctrl+Cでも安全に止まるサーバ

---

## Week 7：DBを現場に寄せる（FWでのDB接続・Tx・マイグレーション）
**目標:** 「FW + DB」の基本形を固める（移行、Tx、repo分離）。

### Day 38: SQLite→PostgreSQLへ移行（ローカル）
- 学習項目: docker-composeでPostgres、接続の管理
- 成果物: compose追加 + 接続先をPostgresへ

### Day 39: マイグレーション導入（運用の入口）
- 学習項目: ツール選定、up/down、ロールバックの考え方
- 成果物: migrations + READMEに手順

### Day 40: Repository層の整理（FWからDBを隔離）
- 学習項目: handler/service/repo の薄い分離、依存方向
- 成果物: DBアクセスをrepoへ寄せる（FW依存をrepoに入れない）

### Day 41: トランザクション（Txが必要な箇所を作る）
- 学習項目: Txの境界、commit/rollback、失敗時の扱い
- 成果物: 1処理をTx化

### Day 42: インデックスと `EXPLAIN` の入口
- 学習項目: index設計の最小原則、遅い時の第一歩
- 成果物: index追加 + `EXPLAIN` メモ

### Day 43: 冪等性（DB制約 or アプリで担保）
- 学習項目: 二重送信、ユニーク制約、再試行
- 成果物: 二重作成を防ぐ仕組みを1つ入れる

### Day 44: 週次まとめ（DB運用手順を残す）
- 学習項目: 初期化/移行/戻しの文章化
- 成果物: READMEにDB運用手順追記

---

## Week 8：認証・認可（FWのミドルウェアとして身につける）
**目標:** 「FWで認証/認可を組む」経験を残す（現場要求が強い）。

### Day 45: 認証方式を決める（Cookie/JWT）
- 学習項目: 方式の選定軸、脅威と対策の入口
- 成果物: READMEに方式と理由

### Day 46: ユーザー登録・ログイン（最小）
- 学習項目: bcrypt、失敗時レスポンス、ログに出してはいけない情報
- 成果物: `/signup` `/login` 実装

### Day 47: 認証middleware（FW流儀）
- 学習項目: 認証情報をcontextへ、ルートグループで保護
- 成果物: TODO作成/更新などを認証必須に

### Day 48: 認可（RBAC最小）
- 学習項目: role（admin/user）、禁止時レスポンス
- 成果物: admin専用APIを1つ追加 + テスト

### Day 49: マルチテナントの入口（概要でOK）
- 学習項目: tenant_id、データ分離、認可と絡む論点
- 成果物: “やるならこうする” メモ（軽い実装でもOK）

### Day 50: セキュリティ最低限（FW設定含む）
- 学習項目: CORS、入力検証、Secrets、ログマスキング
- 成果物: CORS設定 + Secrets方針メモ

### Day 51: 週次まとめ（権限表を作る）
- 学習項目: 誰が何できるかの一覧化
- 成果物: 権限表 + 認証/認可テスト追加

---

## Week 9：テスト戦略・品質ゲート（FW前提のテストが書ける）
**目標:** “FWに載ったAPI” を壊れにくくする（足切り超え）。

### Day 52: FWルータ込みの結合テスト（httptest）
- 学習項目: ルータ生成、リクエスト組み立て、レスポンス検証
- 成果物: APIの結合テスト数本

### Day 53: DB込み統合テスト（compose + migrate）
- 学習項目: テストDBの立て方、テストの独立性
- 成果物: DB込みテスト1本（migrate→test→cleanup）

### Day 54: テストデータ設計（seed/fixture）
- 学習項目: 固定/ランダムの使い分け、再現性
- 成果物: `testdata` / seed整備

### Day 55: race detector（並行バグの足切り対策）
- 学習項目: `go test -race`、よくある事故
- 成果物: `-race` を回す手順/方針メモ（CIに入れてもOK）

### Day 56: fuzzの入口（入力境界の守り）
- 学習項目: fuzzの使いどころ
- 成果物: 小さな関数にfuzzテスト1つ

### Day 57: ベンチの入口（計測癖）
- 学習項目: `testing.B`、改善の手順
- 成果物: 1ベンチ + 計測メモ

### Day 58: コードレビュー観点表（FW視点も追加）
- 学習項目: Correctness/Design/Readability/Test/Security/Perf + FWの作法（middleware/handler責務）
- 成果物: 観点表をREADMEに置く + セルフレビューで修正

---

## Week 10：DevOps/運用（FWアプリを“配れる形”に）
**目標:** 再現性・運用性を付けて「現場の完成形」に寄せる。

### Day 59: Docker化（FWアプリ、マルチステージ）
- 学習項目: 小さいイメージ、実行ユーザー、env注入
- 成果物: Dockerfile（マルチステージ）+ 起動手順

### Day 60: CI + API仕様（OpenAPI）+ Runbook（最終まとめ）
- 学習項目: CIで lint/test、API仕様の残し方、障害時初動
- 成果物:
  - GitHub Actions（lint/test）
  - API仕様（OpenAPIを手書きでも生成でもOK）をREADMEから辿れる
  - Runbook雛形（落ちた/遅い/DB繋がらない の初動）
  - デプロイ/ロールバック手順（演習レベル）

---

### Day 60以降の学習計画予定
- Goの標準的なスタイルで構成されたWebアプリケーションを一つAIに作らせる
- 構築手順は手順書を作成してそれに則ってWebアプリケーションを作成する
- 基本的に私はコードを書かない（写経もしない）
- 仕事の現場レベルでプロジェクトの完成形の初期状態まで一通りの機能が出来上がったら機能追加のタスクをAIにやらせる
- それも人間を模してコードを読み解くところから実装までの流れをAIに詳細に書かせる
- それに則って実装をしていく
- 以上のステップにおいてGoの標準的なスタイルのWebアプリケーションの構築手順、機能追加手順を理解したら最後にテストとして私が一つ機能追加のタスクを実行する（もちろんAIを活用していい）
- これらをすることでGoの標準的なアプリケーションのスタイルを仕事の現場における最低限のボリュームのレベルで把握が出来て、コードの読み書き、機能追加も出来るようにする